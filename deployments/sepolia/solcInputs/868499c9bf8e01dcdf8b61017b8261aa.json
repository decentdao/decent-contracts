{
  "language": "Solidity",
  "sources": {
    "@gnosis.pm/safe-contracts/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IAvatar {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    /// @dev Enables a module on the avatar.\n    /// @notice Can only be called by the avatar.\n    /// @notice Modules should be stored as a linked list.\n    /// @notice Must emit EnabledModule(address module) if successful.\n    /// @param module Module to be enabled.\n    function enableModule(address module) external;\n\n    /// @dev Disables a module on the avatar.\n    /// @notice Can only be called by the avatar.\n    /// @notice Must emit DisabledModule(address module) if successful.\n    /// @param prevModule Address that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) external;\n\n    /// @dev Allows a Module to execute a transaction.\n    /// @notice Can only be called by an enabled module.\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success);\n\n    /// @dev Allows a Module to execute a transaction and return data\n    /// @notice Can only be called by an enabled module.\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success, bytes memory returnData);\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) external view returns (bool);\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize)\n        external\n        view\n        returns (address[] memory array, address next);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/DecentHats_0_1_0.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport {IAvatar} from \"@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC6551Registry} from \"./interfaces/IERC6551Registry.sol\";\nimport {IHats} from \"./interfaces/hats/IHats.sol\";\nimport {ISablierV2LockupLinear} from \"./interfaces/sablier/ISablierV2LockupLinear.sol\";\nimport {LockupLinear} from \"./interfaces/sablier/LockupLinear.sol\";\n\ncontract DecentHats_0_1_0 {\n    string public constant NAME = \"DecentHats_0_1_0\";\n\n    struct SablierStreamParams {\n        ISablierV2LockupLinear sablier;\n        address sender;\n        uint128 totalAmount;\n        address asset;\n        bool cancelable;\n        bool transferable;\n        LockupLinear.Timestamps timestamps;\n        LockupLinear.Broker broker;\n    }\n\n    struct Hat {\n        uint32 maxSupply;\n        string details;\n        string imageURI;\n        bool isMutable;\n        address wearer;\n        SablierStreamParams[] sablierParams; // Optional Sablier stream parameters\n    }\n\n    struct CreateTreeParams {\n        IHats hatsProtocol;\n        address hatsAccountImplementation;\n        IERC6551Registry registry;\n        address keyValuePairs;\n        string topHatDetails;\n        string topHatImageURI;\n        Hat adminHat;\n        Hat[] hats;\n    }\n\n    function getSalt() public pure returns (bytes32 salt) {\n        return\n            0x5d0e6ce4fd951366cc55da93f6e79d8b81483109d79676a04bcc2bed6a4b5072;\n    }\n\n    function declareSafeHatTree(\n        address _keyValuePairs,\n        uint256 topHatId\n    ) internal {\n        string[] memory keys = new string[](1);\n        string[] memory values = new string[](1);\n        keys[0] = \"topHatId\";\n        values[0] = Strings.toString(topHatId);\n\n        IAvatar(msg.sender).execTransactionFromModule(\n            _keyValuePairs,\n            0,\n            abi.encodeWithSignature(\n                \"updateValues(string[],string[])\",\n                keys,\n                values\n            ),\n            Enum.Operation.Call\n        );\n    }\n\n    function createHat(\n        IHats _hatsProtocol,\n        uint256 adminHatId,\n        Hat memory _hat,\n        address topHatAccount\n    ) internal returns (uint256) {\n        return\n            _hatsProtocol.createHat(\n                adminHatId,\n                _hat.details,\n                _hat.maxSupply,\n                topHatAccount,\n                topHatAccount,\n                _hat.isMutable,\n                _hat.imageURI\n            );\n    }\n\n    function createAccount(\n        IERC6551Registry _registry,\n        address _hatsAccountImplementation,\n        bytes32 salt,\n        address protocolAddress,\n        uint256 hatId\n    ) internal returns (address) {\n        return\n            _registry.createAccount(\n                _hatsAccountImplementation,\n                salt,\n                block.chainid,\n                protocolAddress,\n                hatId\n            );\n    }\n\n    function createTopHatAndAccount(\n        IHats _hatsProtocol,\n        string memory _topHatDetails,\n        string memory _topHatImageURI,\n        IERC6551Registry _registry,\n        address _hatsAccountImplementation,\n        bytes32 salt\n    ) internal returns (uint256 topHatId, address topHatAccount) {\n        topHatId = _hatsProtocol.mintTopHat(\n            address(this),\n            _topHatDetails,\n            _topHatImageURI\n        );\n\n        topHatAccount = createAccount(\n            _registry,\n            _hatsAccountImplementation,\n            salt,\n            address(_hatsProtocol),\n            topHatId\n        );\n    }\n\n    function createHatAndAccountAndMintAndStreams(\n        IHats hatsProtocol,\n        uint256 adminHatId,\n        Hat calldata hat,\n        address topHatAccount,\n        IERC6551Registry registry,\n        address hatsAccountImplementation,\n        bytes32 salt\n    ) internal returns (uint256 hatId, address accountAddress) {\n        hatId = createHat(hatsProtocol, adminHatId, hat, topHatAccount);\n\n        accountAddress = createAccount(\n            registry,\n            hatsAccountImplementation,\n            salt,\n            address(hatsProtocol),\n            hatId\n        );\n\n        if (hat.wearer != address(0)) {\n            hatsProtocol.mintHat(hatId, hat.wearer);\n        }\n\n        for (uint256 i = 0; i < hat.sablierParams.length; ) {\n            SablierStreamParams memory sablierParams = hat.sablierParams[i];\n\n            // Approve tokens for Sablier\n            IAvatar(msg.sender).execTransactionFromModule(\n                sablierParams.asset,\n                0,\n                abi.encodeWithSignature(\n                    \"approve(address,uint256)\",\n                    address(sablierParams.sablier),\n                    sablierParams.totalAmount\n                ),\n                Enum.Operation.Call\n            );\n\n            LockupLinear.CreateWithTimestamps memory params = LockupLinear\n                .CreateWithTimestamps({\n                    sender: sablierParams.sender,\n                    recipient: accountAddress,\n                    totalAmount: sablierParams.totalAmount,\n                    asset: IERC20(sablierParams.asset),\n                    cancelable: sablierParams.cancelable,\n                    transferable: sablierParams.transferable,\n                    timestamps: sablierParams.timestamps,\n                    broker: sablierParams.broker\n                });\n\n            // Proxy the Sablier call through IAvatar\n            IAvatar(msg.sender).execTransactionFromModule(\n                address(sablierParams.sablier),\n                0,\n                abi.encodeWithSignature(\n                    \"createWithTimestamps((address,address,uint128,address,bool,bool,(uint40,uint40,uint40),(address,uint256)))\",\n                    params\n                ),\n                Enum.Operation.Call\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    function createRoleHat(\n        IHats hatsProtocol,\n        uint256 adminHatId,\n        Hat calldata hat,\n        uint256 topHatId,\n        address topHatAccount,\n        IERC6551Registry registry,\n        address hatsAccountImplementation,\n        bytes32 salt\n    ) public returns (uint256 hatId, address accountAddress) {\n        (hatId, accountAddress) = createHatAndAccountAndMintAndStreams(\n            hatsProtocol,\n            adminHatId,\n            hat,\n            topHatAccount,\n            registry,\n            hatsAccountImplementation,\n            salt\n        );\n\n        hatsProtocol.transferHat(topHatId, address(this), msg.sender);\n    }\n\n    function createAndDeclareTree(CreateTreeParams calldata params) public {\n        bytes32 salt = getSalt();\n\n        (uint256 topHatId, address topHatAccount) = createTopHatAndAccount(\n            params.hatsProtocol,\n            params.topHatDetails,\n            params.topHatImageURI,\n            params.registry,\n            params.hatsAccountImplementation,\n            salt\n        );\n\n        declareSafeHatTree(params.keyValuePairs, topHatId);\n\n        (uint256 adminHatId, ) = createHatAndAccountAndMintAndStreams(\n            params.hatsProtocol,\n            topHatId,\n            params.adminHat,\n            topHatAccount,\n            params.registry,\n            params.hatsAccountImplementation,\n            salt\n        );\n\n        for (uint256 i = 0; i < params.hats.length; ) {\n            createHatAndAccountAndMintAndStreams(\n                params.hatsProtocol,\n                adminHatId,\n                params.hats[i],\n                topHatAccount,\n                params.registry,\n                params.hatsAccountImplementation,\n                salt\n            );\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        params.hatsProtocol.transferHat(topHatId, address(this), msg.sender);\n    }\n}\n"
    },
    "contracts/interfaces/hats/IHats.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\ninterface IHats {\n    function mintTopHat(\n        address _target,\n        string memory _details,\n        string memory _imageURI\n    ) external returns (uint256 topHatId);\n\n    function createHat(\n        uint256 _admin,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) external returns (uint256 newHatId);\n\n    function mintHat(\n        uint256 _hatId,\n        address _wearer\n    ) external returns (bool success);\n\n    function transferHat(uint256 _hatId, address _from, address _to) external;\n}\n"
    },
    "contracts/interfaces/IERC6551Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IERC6551Registry {\n    /**\n     * @dev Creates a token bound account for a non-fungible token.\n     *\n     * If account has already been created, returns the account address without calling create2.\n     *\n     * Emits ERC6551AccountCreated event.\n     *\n     * @return account The address of the token bound account\n     */\n    function createAccount(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external returns (address account);\n}\n"
    },
    "contracts/interfaces/sablier/ISablierV2LockupLinear.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {LockupLinear} from \"./LockupLinear.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISablierV2LockupLinear {\n    function createWithTimestamps(\n        LockupLinear.CreateWithTimestamps calldata params\n    ) external returns (uint256 streamId);\n}\n"
    },
    "contracts/interfaces/sablier/LockupLinear.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nlibrary LockupLinear {\n    struct CreateWithTimestamps {\n        address sender;\n        address recipient;\n        uint128 totalAmount;\n        IERC20 asset;\n        bool cancelable;\n        bool transferable;\n        Timestamps timestamps;\n        Broker broker;\n    }\n\n    struct Timestamps {\n        uint40 start;\n        uint40 cliff;\n        uint40 end;\n    }\n\n    struct Broker {\n        address account;\n        uint256 fee;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}