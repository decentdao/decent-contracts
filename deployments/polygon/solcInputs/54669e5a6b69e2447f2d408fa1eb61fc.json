{
  "language": "Solidity",
  "sources": {
    "@gnosis.pm/safe-contracts/contracts/common/Enum.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\npragma solidity >=0.7.0 <0.9.0;\n\n/// @title Enum - Collection of enums\n/// @author Richard Meissner - <richard@gnosis.pm>\ncontract Enum {\n    enum Operation {Call, DelegateCall}\n}\n"
    },
    "@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol": {
      "content": "// SPDX-License-Identifier: LGPL-3.0-only\n\n/// @title Zodiac Avatar - A contract that manages modules that can execute transactions via this contract.\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\n\ninterface IAvatar {\n    event EnabledModule(address module);\n    event DisabledModule(address module);\n    event ExecutionFromModuleSuccess(address indexed module);\n    event ExecutionFromModuleFailure(address indexed module);\n\n    /// @dev Enables a module on the avatar.\n    /// @notice Can only be called by the avatar.\n    /// @notice Modules should be stored as a linked list.\n    /// @notice Must emit EnabledModule(address module) if successful.\n    /// @param module Module to be enabled.\n    function enableModule(address module) external;\n\n    /// @dev Disables a module on the avatar.\n    /// @notice Can only be called by the avatar.\n    /// @notice Must emit DisabledModule(address module) if successful.\n    /// @param prevModule Address that pointed to the module to be removed in the linked list\n    /// @param module Module to be removed.\n    function disableModule(address prevModule, address module) external;\n\n    /// @dev Allows a Module to execute a transaction.\n    /// @notice Can only be called by an enabled module.\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execTransactionFromModule(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success);\n\n    /// @dev Allows a Module to execute a transaction and return data\n    /// @notice Can only be called by an enabled module.\n    /// @notice Must emit ExecutionFromModuleSuccess(address module) if successful.\n    /// @notice Must emit ExecutionFromModuleFailure(address module) if unsuccessful.\n    /// @param to Destination address of module transaction.\n    /// @param value Ether value of module transaction.\n    /// @param data Data payload of module transaction.\n    /// @param operation Operation type of module transaction: 0 == call, 1 == delegate call.\n    function execTransactionFromModuleReturnData(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Enum.Operation operation\n    ) external returns (bool success, bytes memory returnData);\n\n    /// @dev Returns if an module is enabled\n    /// @return True if the module is enabled\n    function isModuleEnabled(address module) external view returns (bool);\n\n    /// @dev Returns array of modules.\n    /// @param start Start of the page.\n    /// @param pageSize Maximum number of modules that should be returned.\n    /// @return array Array of modules.\n    /// @return next Start of the next page.\n    function getModulesPaginated(address start, uint256 pageSize)\n        external\n        view\n        returns (address[] memory array, address next);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/DecentHats.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity =0.8.19;\n\nimport {Enum} from \"@gnosis.pm/safe-contracts/contracts/common/Enum.sol\";\nimport {IAvatar} from \"@gnosis.pm/zodiac/contracts/interfaces/IAvatar.sol\";\nimport {IHats} from \"./interfaces/hats/IHats.sol\";\nimport {IERC6551Registry} from \"./interfaces/IERC6551Registry.sol\";\nimport {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract DecentHats {\n    struct Hat {\n        address eligibility;\n        uint32 maxSupply;\n        address toggle;\n        string details;\n        string imageURI;\n        bool isMutable;\n        address wearer;\n    }\n\n    IHats public hats;\n    address public hatsAccountImplementation;\n    IERC6551Registry public registry;\n    address public keyValuePairs;\n\n    bytes32 public constant SALT = keccak256(\"DecentHats\");\n\n    constructor(\n        IHats _hats,\n        address _hatsAccountImplementation,\n        IERC6551Registry _registry,\n        address _keyValuePairs\n    ) {\n        hats = _hats;\n        hatsAccountImplementation = _hatsAccountImplementation;\n        registry = _registry;\n        keyValuePairs = _keyValuePairs;\n    }\n\n    function createAndDeclareTree(\n        string memory _topHatDetails,\n        string memory _topHatImageURI,\n        Hat calldata _adminHat,\n        Hat[] calldata _hats\n    ) public {\n        uint256 topHatId = hats.mintTopHat(\n            address(this),\n            _topHatDetails,\n            _topHatImageURI\n        );\n        registry.createAccount(\n            hatsAccountImplementation,\n            SALT,\n            block.chainid,\n            address(hats),\n            topHatId\n        );\n\n        string[] memory keys = new string[](1);\n        keys[0] = \"topHatId\";\n\n        string[] memory values = new string[](1);\n        values[0] = Strings.toString(topHatId);\n\n        IAvatar(msg.sender).execTransactionFromModule(\n            keyValuePairs,\n            0,\n            abi.encodeWithSignature(\n                \"updateValues(string[],string[])\",\n                keys,\n                values\n            ),\n            Enum.Operation.Call\n        );\n\n        uint256 adminHatId = hats.createHat(\n            topHatId,\n            _adminHat.details,\n            _adminHat.maxSupply,\n            _adminHat.eligibility,\n            _adminHat.toggle,\n            _adminHat.isMutable,\n            _adminHat.imageURI\n        );\n        registry.createAccount(\n            hatsAccountImplementation,\n            SALT,\n            block.chainid,\n            address(hats),\n            adminHatId\n        );\n\n        if (_adminHat.wearer != address(0)) {\n            hats.mintHat(adminHatId, _adminHat.wearer);\n        }\n\n        for (uint256 i = 0; i < _hats.length; ) {\n            Hat memory hat = _hats[i];\n            uint256 hatId = hats.createHat(\n                adminHatId,\n                hat.details,\n                hat.maxSupply,\n                hat.eligibility,\n                hat.toggle,\n                hat.isMutable,\n                hat.imageURI\n            );\n            registry.createAccount(\n                hatsAccountImplementation,\n                SALT,\n                block.chainid,\n                address(hats),\n                hatId\n            );\n\n            if (hat.wearer != address(0)) {\n                hats.mintHat(hatId, hat.wearer);\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n\n        hats.transferHat(topHatId, address(this), msg.sender);\n    }\n}\n"
    },
    "contracts/interfaces/hats/IHats.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\n// Copyright (C) 2023 Haberdasher Labs\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity >=0.8.13;\n\ninterface IHats {\n    function mintTopHat(\n        address _target,\n        string memory _details,\n        string memory _imageURI\n    ) external returns (uint256 topHatId);\n\n    function createHat(\n        uint256 _admin,\n        string calldata _details,\n        uint32 _maxSupply,\n        address _eligibility,\n        address _toggle,\n        bool _mutable,\n        string calldata _imageURI\n    ) external returns (uint256 newHatId);\n\n    function mintHat(\n        uint256 _hatId,\n        address _wearer\n    ) external returns (bool success);\n\n    function transferHat(uint256 _hatId, address _from, address _to) external;\n}\n"
    },
    "contracts/interfaces/IERC6551Registry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IERC6551Registry {\n    /**\n     * @dev The registry MUST emit the ERC6551AccountCreated event upon successful account creation.\n     */\n    event ERC6551AccountCreated(\n        address account,\n        address indexed implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address indexed tokenContract,\n        uint256 indexed tokenId\n    );\n\n    /**\n     * @dev The registry MUST revert with AccountCreationFailed error if the create2 operation fails.\n     */\n    error AccountCreationFailed();\n\n    /**\n     * @dev Creates a token bound account for a non-fungible token.\n     *\n     * If account has already been created, returns the account address without calling create2.\n     *\n     * Emits ERC6551AccountCreated event.\n     *\n     * @return account The address of the token bound account\n     */\n    function createAccount(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external returns (address account);\n\n    /**\n     * @dev Returns the computed token bound account address for a non-fungible token.\n     *\n     * @return account The address of the token bound account\n     */\n    function account(\n        address implementation,\n        bytes32 salt,\n        uint256 chainId,\n        address tokenContract,\n        uint256 tokenId\n    ) external view returns (address account);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}